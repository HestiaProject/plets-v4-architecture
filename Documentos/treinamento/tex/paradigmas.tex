\chapter{Programming Paradigms}
\label{ch:paradigms}

The concept of Programming Paradigms is formally described by Van Roy and Haridi \cite{VANROY:2004} as ``an approach to programming a computer based on a mathematical theory or a coherent set of principles''. A programming language-oriented definition, given by Ghezzi and Jayazeri \cite{GHEZZI:1997}, is that (paraphrase) ``a programming paradigm is the way by which a programming language enforces a certain programming style''. Finally, a more practical definition is given by Van Roy in \cite{VANROY:2009} (paraphrased): ``A paradigm is defined by a set of programming concepts''. While all three may seem too academic an introduction to the subject, a careful analysis of these definitions can yield a good understanding of what programming paradigms mean and how they affect Software Engineering.

First, let us look at the more academical definition given by Van Roy and Haridi. The foremost characteristic of this definition, in comparison to the more orthodox one given by Ghezzi and Jayazeri, is the complete omission of the term ``programming language''. This is important because it emphasizes that a programming paradigm is \emph{not just a characteristic of a language}, but rather an \emph{approach to computational solutions}. Programming paradigms encode certain concepts and practices that have been found to be suitable for solving particular types of problems. They are a ``mathematical theory'' or a ``coherent set of principles'', and understanding the theory and principles behind a programming paradigm is extremely important for understanding how it works, what it is meant for and how best to use it.

Looking at the definition given by Ghezzi and Jayazeri, what we have is a direct correlation between programming paradigms and programming languages through what they call a \emph{programming style}. The premise behind this definition is that programming languages must be studied within the context of software development, as this is their purpose, and therefore must be coherent with the rest of the theory of computer science, particularly Software Engineering. The authors propose that the study of programming paradigms must be seen from the viewpoint of Software Engineering, particularly software design methods. The core idea here is encoded in the following sentence: ``Ideally, the design method and the paradigm supported by the language should be the same''. That is, the choice of a programming paradigm, and indeed the choice of a programming language, must be made in conjunction with the choices in design method and, consequently, with the choices in software development process. The understanding of programming paradigms is therefore essential to Software Engineering.

Finally, we have the definition given by Van Roy in his tutorial of programming concepts. This definition, unlike the previous two, is more direct and concrete, and tells of the composition of a programming paradigm, rather than its purpose or inspiration. Essentially, Van Roy is stating that programming paradigms are similar in that they share certain commonalities. Understanding these commonalities, called programming concepts by Van Roy and programming language concepts by Ghezzi and Jayazeri, allows one to better evaluate a particular paradigm in regards to what it is suited for, what are its limitations and how it is best used. By studying these ``building blocks'' of programming paradigms, a Software Engineer is better able to identify which design techniques to use and what processes suit what technologies.

This chapter is written following these three main precepts of programming paradigms: a) that there is strong and formal theory behind each paradigm; b) that understanding and choosing paradigms needs to be a part of the software development process, and; c) that understanding programming concepts allows one to better evaluate different paradigms. While the formal theory of programming language concepts is not presented in full, both due to lack of time and space and due to it not being the objective of this training programme, we do explore the theory of a few fundamental programming concepts and what they represent. Once a few concepts have been studied, specific paradigms will be presented to evaluate the ability of the trainees in identifying programming concepts. These paradigms are presented in comparison to one another, and were chosen due either to their representativeness of certain concepts or to their practical application within the environment of the ProjetoMBT group.

Upon completion of this stage of the training programme, the trainee should:

\begin{itemize}
  \item understand the relationship between programming languages and paradigms;
  \item understand the fundaments of the presented programming concepts, and;
  \item understand the differences between the Imperative, Object-Oriented and Declarative programming paradigm types.
\end{itemize}

%-----------------------------------------------

\section{Programming Concepts}

%-----------------------------------------------

\subsection{Record}

%-----------------------------------------------

\subsection{Procedure}

%-----------------------------------------------

\subsection{State}

%-----------------------------------------------

\subsection{Object}

%-----------------------------------------------

\subsection{Class}

%-----------------------------------------------

\subsection{Port}

%-----------------------------------------------

\subsection{Cell}

%-----------------------------------------------

\subsection{Inheritance}

%-----------------------------------------------

\subsection{Exception}

%-----------------------------------------------

\section{Paradigms}

%-----------------------------------------------

\subsection{Imperative}

%-----------------------------------------------

\subsubsection{Procedural}

%-----------------------------------------------

\subsection{Object-Oriented}

%-----------------------------------------------

\subsubsection{Event-Driven}

%-----------------------------------------------

\subsubsection{Reflective}

%-----------------------------------------------

\subsubsection{Aspect-Oriented}

%-----------------------------------------------

\subsection{Declarative}

%-----------------------------------------------

\subsubsection{Functional}

%-----------------------------------------------

\subsubsection{Logic}
