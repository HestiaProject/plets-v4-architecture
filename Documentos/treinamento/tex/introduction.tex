\chapter*{Introduction}

Welcome to the ProjetoMBT training program. In this document, you should be able to find all the necessary material to guide you in studying the topics used in our project, be it in theory, analysis, architecture or development. The goal of this document is to help you navigate through the sources for each topic and direct your studies to each topic's most important parts. This is NOT meant to serve as a sole material for studying these topics, as it is vastly incomplete and operates under the expectation that the student will use complementary material as needed.

This document is an ongoing project, and as such any errors or incomplete sections should be notified to the author (marcelo.laser@gmail.com). It is written in English on purpose, so as to help in the study of the language and to evaluate the ability of the trainees in assessing English literature, a skill that is fundamental to the participation in this project. Each of the following paragraphs summarizes one of the document's chapters, explaining and listing its purpose, topics covered, primary sources used and possibly interested parties.

Chapter \ref{ch:paradigms} discusses the topic of Programming Paradigms, and is meant to give the trainee a foundation of programming concepts. The purpose of this chapter is to show the differences between some programming paradigms in order to expose the notion of basic programming concepts. This way, the trainee should be able to identify more precisely what programming paradigms mean and understand how paradigms can be implemented in various languages. The paradigms explored in this chapter are Imperative (with a particular distinction with Procedural), Object-Oriented, Aspect-Oriented, Declarative, Functional, Logical, Event-Driven and Reflective. This chapter is primarily directed towards programmers, and is based on the works of Van Roy et al. \cite{VANROY:2004} and Ghezzi et al. \cite{GHEZZI:1997}.

Chapter \ref{ch:logic} discusses the basic concepts of logic for programming, with an emphasis on its uses for defining architectural constraints in software projects. The purpose of this chapter is to open the trainee to the notion of formal logic so that he may identify its overall applications. This chapter is meant only as an introduction to formal logic, and is intended to help the trainees develop the skillset related to it, not explain its practical applications. The specific logics addressed are Propositional Logic and First-Order Logic. This chapter is primarily directed at software engineers and architects, and is based on the work of Huth et al. \cite{HUTH:2004}.

Chapter \ref{ch:modeling} is meant as a review of software modeling concepts, with an emphasis on the UML. The purpose of this chapter is to reinforce the importance and practical application of software modeling, as well as the formal notion of software model, in order to improve the communication between members of the project. First the fundamental concepts of software modeling are presented, followed by a more in-depth exposition of certain UML diagrams (Use-Case, Activity, Class, Component, Sequence, Communications and State-Machine) and an overview of some other modeling languages and techniques. This chapter is directed at all team members, as software models are the primary means of communication within a software project. Several sources are used in this chapter, of which the main ones are the works of Taylor et al. \cite{TAYLOR:2009} and Rumbaugh et al. \cite{RUMBAUGH:2004} \cite{BOOCH:2005}.

Chapter \ref{ch:datastructures} presents an extensive treatment of Data Structures, ranging from theory and characteristics, through implementation, and ending with advantages and recommendations of each one covered. The purpose of this chapter is to enhance the understanding of the trainees regarding data structures and their importance in software architecture and development, especially in regards to how appropriate use of data structures can increase modularization and facilitate separation of concerns. The data structures covered are Arrays, Matrices, Lists (Array Lists and Linked Lists), Stacks and Queues, Trees (with an emphasis on Binary Trees and Heaps), Graphs, Classes and Tables (particularly Hash Tables and Dictionaries). This chapter is primarily directed towards programmers, though understanding it is important for low-level software engineers, particularly those that intend to work with data-intensive applications. The primary source used in this chapter is the work of Cormen et al. \cite{CORMEN:2001}.

Chapter \ref{ch:algorithms} expands on the knowledge of Chapter \ref{cg:datastructures} by analysing sorting and search algorithms that are basic for the understanding of algorithm construction and evaluation. This chapter serves the same purpose as Chapter \ref{cg:datastructures}, presenting the importance of well-thought algorithms and standardized solutions in software engineering and development. The algorithms covered are Insertion, Bubble, Merge and Quicksort, and Breadth-First Search, Depth-First Search, A*, Dijkstra's Algorithm and Floyd-Warshall. This chapter is primarily directed at programmers, but low-level software engineers might benefit from these concepts as they are essential for architecting appropriate data-intensive applications. The primary source used in this chapter is the work of Cormen et al. \cite{CORMEN:2001}.

Chapter \ref{ch:patterns} delves into the basic concepts of Software Patterns, the different types of patterns, the reasons for using patterns and the specifics of certain important patterns. This chapter is meant to aid in solving a large number of common problems in Software Engineering, as Software Patterns are an indispensable tool. The number of patterns covered in this chapter is very high, and therefore a complete list is not presented here. The study of patterns is the culmination of the topics seen up to this point, combining Programming Paradigm Concepts, Data Structures and Algorithms to solve practical Software Engineering problems, and making use of Formal Logic and Software Modeling to present these solutions in a concise manner. Knowledge of software patterns is indispensable to any serious Software Engineer, and therefore this chapter is directed to all trainees. The sources used in this chapter are mainly the works of Taylor et al. \cite{TAYLOR:2009}, the Gang of Four \cite{GAMMA:1995} and Fowler et al. \cite{FOWLER:2002}.

Chapter \ref{ch:compilers} covers the notions of Formal Languages, with a broad introduction to the subject and its practical application in the field of Model-Based Testing, and indeed, all of Model-Based Software Engineering. As compilers theory forms the essential building blocks to all computational parsing, it is important to understand what compilers are, what they do and how they are formed, and that is what this chapter aims to do. It is not meant as a comprehensive explanation for implementing compilers, as that is beyond the scope of this training. The specific topics viewed are Regular Expressions, Automata Theory (very superficially), Lexical, Syntactic and Semantic Analysis (also superficially) and the basics of the Backus-Naur Form of grammars. This chapter is primarily directed at developers and Software Engineers with an interest in Model-Based Software Engineering. The sources used are the works of Aho et al. \cite{AHO:2006} and Hopcroft et al. \cite{HOPCROFT:2000}.

Chapter \ref{ch:test}
